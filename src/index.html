<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>✨Character Traits and Attributes Generator✨</title>
  <style>
    @property --hue {
      syntax: '<number>';
      initial-value: 0;
      inherits: false;
    }

    @keyframes rainbow {
      0% {
        --hue: 0;
      }

      100% {
        --hue: 360;
      }
    }

    a {
      color: #00aaaa;
      /* Light blue color */
    }

    body {
      color: #aaa;
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
      --value: 5%;
      --value-2: 10%;
      background-image: linear-gradient(to bottom right,
          hsl(calc(var(--hue) * 1deg), 100%, var(--value)),
          hsl(calc((var(--hue) + 180) * 1deg), 100%, var(--value-2)));
      animation: rainbow 60s linear infinite;
    }

    #attributes,
    #traits {
      margin-bottom: 20px;
    }

    .attribute,
    .trait {
      margin-bottom: 10px;
    }

    input,
    button,
    #customPrompt {
      background: #33333344
    }

    input,
    #customPrompt {
      color: #fff;
      border: none;
      padding: 10px;
      width: 100%;
      box-sizing: border-box;
      border-radius: 15px;
    }

    #customPrompt {
      height: 100px;
      resize: vertical;
      margin-bottom: 20px;
      font-family: Arial, sans-serif;
    }

    #customPrompt::placeholder {
      color: #888;
    }

    button {
      color: #fff;
      border: none;
      margin-top: 10px;
      margin-right: 10px;
      cursor: pointer;
      padding: 10px 20px;
      border-radius: 15px;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #333;
    }

    h1,
    h4 {
      margin-bottom: 20px;
    }

    .spacer {
      padding: 0px 0px;
      flex-grow: 1;
    }

    [title] {
      cursor: help;
    }

    #title {
      text-align: center;
    }

    .background-image-wrapper {
      position: fixed;
      bottom: 0;
      right: 0;
      z-index: -1;
      pointer-events: auto;
    }

    .background-image {
      width: 200px;
      /* Adjust as needed */
      height: auto;
      opacity: 0.5;
      /* Optional: Adjust opacity */
      transition: opacity 0.3s;
    }

    .transparent-element,
    .transparent-element * {
      pointer-events: none;
    }

    #toggleDescription {
      background: #33333344;
      color: #fff;
      border: none;
      padding: 10px 20px;
      border-radius: 15px;
      cursor: pointer;
      transition: background-color 0.3s;
      margin-bottom: 10px;
    }

    #toggleDescription:hover {
      background-color: #333;
    }

    #description {
      background: #33333344;
      padding: 10px 20px;
      border-radius: 15px;
      color: #fff;
    }

    #scrollToTop {
      bottom: 20px;
      right: 50%;
      background: #33333344;
      color: #fff;
      border: none;
      padding: 10px 20px;
      border-radius: 15px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    #scrollToTop:hover {
      background-color: #333;
    }

    .trait-input {
      display: flex;
      align-items: center;
      margin-top: 20px;
    }

    .trait-input input {
      flex-grow: 1;
      margin-right: 10px;
    }

    .trait-input button {
      background: #33333344;
      color: #fff;
      border: none;
      padding: 5px 10px;
      border-radius: 15px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .trait-input button:hover {
      background-color: #333;
    }

    .delete-trait {
      background: #33000044;
      color: #fff;
      border: none;
      padding: 2px 10px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      margin-left: 10px;
    }

    .delete-trait:hover {
      background-color: #300;
    }

    .trait {
      display: flex;
      flex-direction: column;
      margin-bottom: 15px;
      width: 100%
    }

    .trait-header {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .trait-label {
      display: inline-block;
      width: 150px;
      max-width: 150px;
    }

    .trait-top-row {
      display: flex;
      align-items: center;
      width: 100%;
      flex-wrap: wrap;
    }

    .trait-slider {
      -webkit-appearance: none;
      appearance: none;
      flex-grow: 1;
      height: 10px;
      width: auto;
      max-width: 50%;
      offset: 0px 10px;
      padding: 0px;
      margin-top: 20px;
      outline: none;

    }

    .trait-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 25px;
      height: 25px;
      background: #8888;
      border-radius: 25px;
    }

    .trait-slider::-moz-range-thumb {
      border: 0;
      width: 25px;
      height: 25px;
      background: #8888;
      border-radius: 25px;
    }

    .delete-trait,
    .lock {
      background: #33333344;
      color: #fff;
      border: none;
      padding: 2px 10px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      margin-left: 5px;
      font-size: 16px;
    }

    .delete-trait:hover,
    .lock:hover {
      background-color: #333;
    }

    .trait input[type="text"] {
      width: 100%;
      box-sizing: border-box;
    }

    .lock {
      transition: background-color 0.3s ease;
    }

    .lock.locked {
      background-color: rgba(0, 100, 0, 0.5);
      /* Dark transparent green */
    }

    .prompt-box {
      border: 1px solid #33333344;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      background-color: #33333344;
    }

    .prompt-box h2 {
      margin-top: 0;
      color: #f0f0f0;
    }

    #step2Prompts {
      opacity: 0.5;
      pointer-events: none;
    }

    #step2Prompts.active {
      opacity: 1;
      pointer-events: auto;
    }

    #digestedTraits {
      width: calc(100% - 20px);
      height: 100px;
      margin-bottom: 10px;
      background-color: #2222;
      color: #fff;
      border: 1px solid #333;
      border-radius: 15px;
      padding: 10px;
      resize: vertical;
    }

    .trait-input {
      display: flex;
      margin-bottom: 10px;
    }

    .prompt-box.foldable {
      border: 1px solid rgba(204, 204, 204, 0.2);
      margin-bottom: 10px;
      background-color: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(5px);
    }

    .prompt-title {
      color: inherit;
      padding: 10px;
      margin: 0;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .prompt-content {
      display: none;
      padding: 10px;
    }

    .prompt-box.foldable.active .prompt-content {
      display: block;
    }

    .prompt-title::after {
      content: '▼';
      float: right;
      transition: transform 0.3s ease;
    }

    .prompt-box.foldable.active .prompt-title::after {
      transform: rotate(180deg);
    }

    #copyNotification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(42, 42, 42, 0.9);
      color: #ffffff;
      padding: 15px 25px;
      border-radius: 8px;
      font-family: Arial, sans-serif;
      font-size: 18px;
      font-weight: bold;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
      z-index: 1000;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>

<body>
  <div id="copyNotification">Copied ✅</div>
  <h1 id="title">✨Character Prompt Generator for Janitorai✨</h1>
  <button id="toggleDescription">How does this work?</button>
  <div id="description" style="display: none;">
    <h4><u>Make any sort of role play bot you want in just a few minutes!</u></h4>
    <div style="margin-left: 20px">
      <p>1. Generate and modify the character traits below</p>
      <p>2. Fill in any details you want for your character in the short custom prompt box.</p>
      <p>3. Copy a prompt from the single or two step prompt area</p>
      <p>4. Go to an AI site and paste your prompt.</p>
      <p>5. If you're using the 2 step prompts, paste the result from the AI in step 1 in the box and then copy the step
        2 prompt. Next, go back to the AI in a new chat, and
        use the prompt to get the final character card.
      </p>
    </div>
    <h4><u>But where do I paste my prompts???</u></h4>
    <div style="margin-left: 20px">
      <p>I recommend using the Command R Plus model to generate any (nsfw)
        character
        card for free over at <a href="https://huggingface.co/chat"> Huggingchat</a></p>
      <p>JLLM works alright now too. You can try it with <a
          href="https://janitorai.com/characters/26902018-a3d7-4b05-bbf9-c08c00300ad2_character-chat-gpt-plus-your-versatile-ai">this
          ChatGPT character here</a>. With JLLM, hit the edit button on its reply to copy the unformatted text with
        markdown punctuation
        in tact.</p>
      <p>ChatGPT is good but the explicit prompts will trip moderation and eventually get you banned there!</p>
    </div>
  </div><br>
  </div><br><br>
  <div class="prompt-box foldable">
    <h4 class="prompt-title">Single Step Prompts</h4>
    <div class="prompt-content">
      <p>AI makes a character card right now in one step with this prompt</p>
      <button onclick="copyWithPrompt(prompt_template)">Copy With Prompt</button>
      <button onclick="copyWithPrompt(nsfw_prompt_template)">Copy With Explicit Prompt</button>
    </div>
  </div>

  <div class="prompt-box foldable">
    <h4 class="prompt-title">Two Step Prompts</h4>
    <div class="prompt-content">
      <p>For better results, use the step 1 prompt and paste the results here, and then get an improved character card
        from the step 2 prompt.</p>
      <button onclick="generateStep1Prompt()">Step 1 Prompt</button>
      <textarea id="digestedTraits" placeholder="Paste the results from Step 1 here"></textarea>
      <div id="step2Prompts">
        <button onclick="copyWithStep2Prompt(prompt_template)">Step 2 Prompt</button>
        <button onclick="copyWithStep2Prompt(nsfw_prompt_template)">Explicit Step 2 Prompt</button>
      </div>
    </div>
  </div>
  <div>
    <label>Short Prompt:</label>
    <textarea id="customPrompt"
      placeholder="Enter a short custom prompt to guide the AI character generation process, e.g. 'He's a billionaire CEO' (optional)"></textarea>
  </div>
  <button onclick="rerollAll()">Reroll Traits</button>
  <button onclick="copyAll()">Copy Traits</button>
  <button onclick="traitContainer.resetTraits()">Reset Traits</button><br><br>
  <div id="attributes"></div>
  <div id="traits"></div>
  <div class="trait-input">
    <input type="text" id="newTraitInput" placeholder="Add new trait">
    <button>+</button>
  </div>
  <div class="background-image-wrapper">
    <img src="image.webp" alt="Background Image" class="background-image">
  </div>
  <button id="scrollToTop">Top</button><br><br>
  <footer
    style="background-color: #1113; padding: 0px 0; text-align: center; bottom: 0; width: 100%; border-radius: 15px">
    <p style="margin: 0;">
      If you find this tool helpful, consider
      <a href="https://buymeacoffee.com/trainraider" target="_blank">
        buying me a coffee ☕
      </a>
    </p>
  </footer>
  <script>

    const ATTRIBUTES_INFO = {
      'Gender': ['Man', 'Woman'],
      'Age': Array.from({ length: 18 }, (_, i) => i + 18),
      'Era': ['Medieval', 'Modern', 'Futuristic'],
      'World Type': ['Realistic', 'Fantasy'],
      'Race': ['Human', 'Elf', 'Goblin', 'Orc'] // Only if fantasy
    };

    const DEFAULT_TRAITS = [
      'Narcissism', 'Machiavellianism', 'Sadism', 'Psychopathy',
      'Wealth', 'Societal status', 'Strength', 'Intelligence', 'Wisdom',
      'Physical attractiveness', 'Horniness'
    ];

    const PERSONALITY_TRAITS = [
      "Adventurous", "Ambitious", "Analytical", "Arrogant", "Assertive", "Bigotted", "Brave",
      "Careless", "Captivating", "Cautious", "Charismatic", "Cheerful", "Compassionate", "Competent", "Confident",
      "Conservative", "Creative", "Cynical", "Decisive", "Determined", "Diligent", "Dramatic",
      "Dishonest", "Disorganized", "Eccentric", "Empathetic", "Enthusiastic", "Extroverted", "Flirtatious", "Focused",
      "Forgiving", "Generous", "Greedy", "Honest", "Humble", "Idealistic", "Imaginative", "Impulsive",
      "Independent", "Intelligent", "Introverted", "Intuitive", "Irresponsible", "Jealous", "Lazy", "Lecherous", "Liberal",
      "Logical", "Loyal", "Lustful", "Manipulative", "Melancholic", "Meticulous", "Modest", "Naive",
      "Narcissistic", "Neurotic", "Observant", "Optimistic", "Passionate", "Patient", "Perfectionist",
      "Persistent", "Persuasive", "Pessimistic", "Philosophical", "Pragmatic", "Procrastinates", "Prideful", "Rational", "Rebellious",
      "Reckless", "Reserved", "Resourceful", "Romantic", "Sarcastic", "Scholarly", "Self-absorbed", "Selfish",
      "Sensitive", "Sensual", "Skeptical", "Slutty", "Socially awkward", "Stoic", "Stubborn",
      "Suspicious", "Sympathetic", "Tactful", "Temperamental", "Tenacious", "Thoughtful", "Timid",
      "Tolerant", "Treacherous", "Trustworthy", "Uncompromising", "Unpredictable", "Vengeful",
      "Visionary", "Witty", "Wrathful"
    ];

    class LockButton {
      constructor(name) {
        this.name = name;
        this.locked = false;
        this.element = null;
      }

      createLockButton() {
        const lockButton = document.createElement('button');
        lockButton.className = 'lock';
        lockButton.textContent = this.locked ? '🔒' : '🔓';
        lockButton.onclick = () => this.toggleLock();
        return lockButton;
      }

      setElement(element) {
        this.element = element;
        this.updateElementState();
      }

      toggleLock() {
        this.locked = !this.locked;
        this.updateElementState();
      }

      updateElementState() {
        if (this.element) {
          const lockButton = this.element.querySelector('.lock');
          const inputs = this.element.querySelectorAll('input');

          lockButton.textContent = this.locked ? '🔒' : '🔓';
          lockButton.classList.toggle('locked', this.locked);
          inputs.forEach(input => {
            input.disabled = this.locked;
          });
        }
      }

      isLocked() {
        return this.locked;
      }
    }

    class Attribute {
      constructor(name, options) {
        this.name = name;
        this.options = options;
        this.element = null;
        this.lock = new LockButton(name);
        this.value = this.reroll();
      }

      reroll() {
        if (!this.lock.isLocked()) {
          let value = null;
          if (Array.isArray(this.options)) {
            value = this.options[Math.floor(Math.random() * this.options.length)];
          } else {
            value = Math.floor(Math.random() * (this.options[1] - this.options[0] + 1)) + this.options[0];
          }
          this.updateValue(value);
        }
      }

      generateElement() {
        const div = document.createElement('div');
        div.className = 'attribute';

        const lockButton = this.lock.createLockButton();

        div.innerHTML = `
            ${this.name}: <br><br>
            <input type="text" value="${this.value}">
          `;
        div.insertBefore(lockButton, div.firstChild);

        this.element = div;
        this.lock.setElement(div);

        const input = div.querySelector('input');
        input.addEventListener('input', (e) => {
          if (!this.lock.isLocked()) {
            this.value = e.target.value;
          }
        });

        return div;
      }

      generateText() {
        return `${this.name}: ${this.value}`;
      }

      updateValue(newValue) {
        if (!this.lock.isLocked()) {
          this.value = newValue;
          if (this.element) {
            const input = this.element.querySelector('input');
            input.value = newValue;
          }
        }
      }
    }

    class AttributeContainer {
      constructor() {
        this.attributes = {};
      }

      _forEach(callback) {
        Object.values(this.attributes).forEach(callback);
      }

      addAttribute(name, options) {
        this.attributes[name] = new Attribute(name, options);
      }

      generateElements() {
        const attributesElement = document.getElementById('attributes');
        attributesElement.innerHTML = '';
        this._forEach(attribute => attributesElement.appendChild(attribute.generateElement()));
      }

      generateText() {
        let attributesText = '';
        this._forEach(attribute => {
          attributesText += attribute.generateText() + '\n';
        });
        // Remove any leading/trailing whitespace and ensure no empty lines
        attributesText = attributesText.trim().replace(/^\s+/gm, '');
        // Add a single newline at the end
        return attributesText + '\n';
      }

      reroll() {
        this._forEach(attribute => attribute.reroll())
        const worldTypeAttribute = this.attributes['World Type'];
        const raceAttribute = this.attributes['Race'];
        if (worldTypeAttribute && raceAttribute && !raceAttribute.lock.isLocked()) {
          if (worldTypeAttribute.value !== 'Fantasy') {
            raceAttribute.updateValue('Human');
          }
        }
      }
    }

    class Trait {
      constructor(name) {
        this.name = name;
        this.value = Math.floor(Math.random() * 101);
        this.element = null;
        this.lock = new LockButton();
      }

      generateElement() {
        const div = document.createElement('div');
        div.className = 'trait';

        const lockButton = this.lock.createLockButton();

        div.innerHTML = `
                <div class="trait-top-row">
                    <button class="delete-trait" onclick="traitContainer.deleteTrait('${this.name}')">❌</button>
                    <span class="trait-label">${this.name}:</span>
                    <input type="range" class="trait-slider" min="0" max="100" value="${this.value}">
                </div>
                <input type="text" class="trait-input" placeholder="${this.getStrengthModifier()}">
            `;

        const traitTopRow = div.querySelector('.trait-top-row');
        traitTopRow.insertBefore(lockButton, traitTopRow.firstChild);

        this.element = div;
        this.lock.setElement(div);

        const slider = div.querySelector('.trait-slider');
        const input = div.querySelector('.trait-input');

        slider.addEventListener('input', () => {
          this.updateValue(slider.value);
          input.placeholder = this.getStrengthModifier();
          if (!input.value) {
            input.value = '';
          }
        });

        return div;
      }

      reroll() {
        if (!this.lock.isLocked()) {
          let value = Math.floor(Math.random() * 101);
          this.updateValue(value);
        }
      }

      updateValue(newValue) {
        if (!this.lock.isLocked()) {
          this.value = newValue;
          if (this.element) {
            const slider = this.element.querySelector('.trait-slider');
            const input = this.element.querySelector('.trait-input');
            slider.value = newValue;
            input.placeholder = this.getStrengthModifier();
            if (!input.value) {
              input.value = '';
            }
          }
        }
      }

      generateText() {
        const textInput = this.element ? this.element.querySelector('.trait-input').value : '';
        if (textInput) {
          // Check if the input contains the trait name (case-insensitive)
          if (textInput.toLowerCase().includes(this.name.toLowerCase())) {
            return `${textInput}\n`;
          }
          return `${this.name}: ${textInput}\n`;
        } else {
          const strengthModifier = this.getStrengthModifier();
          return `${strengthModifier}\n`;
        }
      }

      getStrengthModifier() {
        const levels = [
          { threshold: 0, modifier: "no {{trait}} at all" },
          { threshold: 10, modifier: "practically nonexistent {{trait}}" },
          { threshold: 20, modifier: "almost no {{trait}}" },
          { threshold: 25, modifier: "very low {{trait}}" },
          { threshold: 35, modifier: "considerably below average {{trait}}" },
          { threshold: 40, modifier: "less than average {{trait}}" },
          { threshold: 45, modifier: "average {{trait}}" },
          { threshold: 50, modifier: "moderate {{trait}}" },
          { threshold: 60, modifier: "above average {{trait}}" },
          { threshold: 70, modifier: "substantial {{trait}}" },
          { threshold: 80, modifier: "remarkable {{trait}}" },
          { threshold: 87, modifier: "extraordinary {{trait}}" },
          { threshold: 94, modifier: "unparalleled {{trait}}" }
        ];

        for (let i = levels.length - 1; i >= 0; i--) {
          if (this.value >= levels[i].threshold) {
            return levels[i].modifier.replace("{{trait}}", this.name.toLowerCase());
          }
        }
        return "invalid {{trait}}".replace("{{trait}}", this.name.toLowerCase());
      }
    }

    class TraitContainer {
      constructor() {
        this.traits = {};
      }

      _forEach(callback) {
        Object.values(this.traits).forEach(callback);
      }

      addTrait(newTraitName) {
        if (newTraitName && !this.traits[newTraitName]) {
          this.traits[newTraitName] = new Trait(newTraitName);
          const traitsElement = document.getElementById('traits');
          traitsElement.appendChild(this.traits[newTraitName].generateElement());
        }
      }

      generateElements(parentElement) {
        parentElement.innerHTML = '';
        this._forEach(trait => parentElement.appendChild(trait.generateElement()));
      }

      generateText() {
        let allTraitText = '';
        this._forEach(trait => allTraitText += trait.generateText());
        return allTraitText;
      }

      reroll() {
        this._forEach(trait => trait.reroll());
      }

      resetTraits() {
        this.traits = {};
        DEFAULT_TRAITS.forEach(traitName => this.addTrait(traitName));
        this.generateElements(document.getElementById('traits'));
      }

      deleteTrait(traitName) {
        delete this.traits[traitName];
        const traitsElement = document.getElementById('traits');
        this.generateElements(traitsElement);
      }
    }
    
    function setupNewTraitInput() {
      const newTraitInput = document.getElementById('newTraitInput');
      const addButton = document.querySelector('.trait-input button');

      newTraitInput.addEventListener('keypress', function (event) {
        const newTraitInput = document.getElementById('newTraitInput');
        const newTraitName = newTraitInput.value.trim();
        if (event.key === 'Enter') {
          event.preventDefault(); // Prevent form submission if it's in a form
          traitContainer.addTrait(newTraitName);
        }
      });

      addButton.onclick = function () {
        const newTraitInput = document.getElementById('newTraitInput');
        const newTraitName = newTraitInput.value.trim();
        traitContainer.addTrait(newTraitName);
      };
    }

    function initializeTraits() {
      DEFAULT_TRAITS.forEach(traitName => traitContainer.addTrait(traitName));
      const traitsElement = document.getElementById('traits');
      traitContainer.generateElements(traitsElement);
    }

    function setupAttributeListeners() {
      const attributesElement = document.getElementById('attributes');
      const attributeInputs = attributesElement.querySelectorAll('input');

      attributeInputs.forEach(input => {
        const attributeName = input.closest('.attribute').textContent.split(':')[0].trim();
        const attribute = attributeContainer.attributes[attributeName];

        input.addEventListener('input', (e) => {
          if (!attribute.locked) {
            attribute.value = e.target.value;
          }
        });
      });
    }

    // Initialize the attribute container
    const attributeContainer = new AttributeContainer();

    // Populate the attribute container
    Object.entries(ATTRIBUTES_INFO).forEach(([key, options]) => {
      attributeContainer.addAttribute(key, options);
    });

    function rerollAll() {
      attributeContainer.reroll();
      traitContainer.reroll();
    }

    function generateStep1Prompt() {
      let allText = generateTraitAttributeText();
      const customPromptText = document.getElementById('customPrompt').value.trim();

      const step1Prompt = `Based on the following information about a character:
        ${allText}
        ${customPromptText}

        And considering this list of personality traits: ${PERSONALITY_TRAITS.join(', ')}
        Please list the personality traits from the provided list that most apply to this character based on the information given. Your list should only be space separated. You can also use traits that weren't listed in your list. Put your answer in a code block.`;

      copyToClipboard(step1Prompt);
    }

    function copyWithStep2Prompt(promptTemplate) {
      const digestedTraits = document.getElementById('digestedTraits').value.trim();
      if (!digestedTraits) {
        return;
      }

      // Generate text for attributes
      let attributesText = attributeContainer.generateText() + 'Personality:\n';
      let allText = attributesText + digestedTraits;

      const customPromptText = document.getElementById('customPrompt').value.trim();
      const finalText = promptTemplate
        .replace('{{traits}}', allText)
        .replace('{{custom_prompt}}', customPromptText);

      copyToClipboard(finalText);
    }

    function generateTraitAttributeText() {
      return attributeContainer.generateText() + traitContainer.generateText();
    }

    function copyToClipboard(text) {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);

      //show copy notification
      const notification = document.getElementById('copyNotification');
      notification.style.opacity = '1';
      notification.style.visibility = 'visible';
      setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.visibility = 'hidden';
      }, 1000);
    }

    function copyAll() {
      let allText = generateTraitAttributeText();
      copyToClipboard(allText);
    }

    function copyWithPrompt(prompt) {
      let allText = generateTraitAttributeText();
      const customPromptText = document.getElementById('customPrompt').value.trim();
      const finalText = prompt
        .replace('{{traits}}', allText)
        .replace('{{custom_prompt}}', customPromptText);

      copyToClipboard(finalText);
    }

    const traitContainer = new TraitContainer();

    document.getElementById('digestedTraits').addEventListener('input', function () {
      const step2Prompts = document.getElementById('step2Prompts');
      if (this.value.trim()) {
        step2Prompts.classList.add('active');
      } else {
        step2Prompts.classList.remove('active');
      }
    });

    document.addEventListener('DOMContentLoaded', (event) => {
      const toggleButton = document.getElementById('toggleDescription');
      const description = document.getElementById('description');

      toggleButton.addEventListener('click', () => {
        if (description.style.display === 'none') {
          description.style.display = 'block';
          toggleButton.textContent = 'Hide';
        } else {
          description.style.display = 'none';
          toggleButton.textContent = 'How does this work?';
        }
      });

      const scrollToTopButton = document.getElementById('scrollToTop');

      scrollToTopButton.addEventListener('click', () => {
        window.scrollTo({ top: 0 });
      });

      const backgroundImageWrapper = document.querySelector('.background-image-wrapper');
      const backgroundImage = document.querySelector('.background-image');

      function checkHover(event) {
        const rect = backgroundImageWrapper.getBoundingClientRect();
        let clientX, clientY;

        if (event.type.includes('touch')) {
          clientX = event.touches[0].clientX;
          clientY = event.touches[0].clientY;
        } else {
          clientX = event.clientX;
          clientY = event.clientY;
        }

        const isHovering = (
          clientX >= rect.left &&
          clientX <= rect.right &&
          clientY >= rect.top &&
          clientY <= rect.bottom
        );

        if (isHovering) {
          backgroundImage.src = 'image2.webp';
        } else {
          backgroundImage.src = 'image.webp';
        }
      }

      document.addEventListener('mousemove', checkHover);
      document.addEventListener('touchmove', checkHover);
      document.addEventListener('touchstart', checkHover); // for initial touch

      const foldableBoxes = document.querySelectorAll('.prompt-box.foldable');

      foldableBoxes.forEach(box => {
        const title = box.querySelector('.prompt-title');
        title.addEventListener('click', () => {
          box.classList.toggle('active');
        });
      });


      setupNewTraitInput();
      initializeTraits();
      attributeContainer.generateElements();
      rerollAll();
      setupAttributeListeners();
    });