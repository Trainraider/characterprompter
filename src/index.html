<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‚ú®Character Traits and Attributes Generator‚ú®</title>
  <style>
    @property --hue {
      syntax: '<number>';
      initial-value: 0;
      inherits: false;
    }

    @keyframes rainbow {
      0% {
        --hue: 0;
      }

      100% {
        --hue: 360;
      }
    }

    a {
      color: #00aaaa;
      /* Light blue color */
    }

    body {
      color: #aaa;
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
      --value: 5%;
      --value-2: 10%;
      background-image: linear-gradient(to bottom right,
          hsl(calc(var(--hue) * 1deg), 100%, var(--value)),
          hsl(calc((var(--hue) + 180) * 1deg), 100%, var(--value-2)));
      animation: rainbow 60s linear infinite;
    }

    #attributes,
    #traits {
      margin-bottom: 20px;
    }

    .attribute,
    .trait {
      margin-bottom: 10px;
    }

    input,
    button,
    #customPrompt {
      background: #33333344
    }

    input,
    #customPrompt {
      color: #fff;
      border: none;
      padding: 10px;
      width: 100%;
      box-sizing: border-box;
      border-radius: 15px;
    }

    #customPrompt {
      height: 100px;
      resize: vertical;
      margin-bottom: 20px;
      font-family: Arial, sans-serif;
    }

    #customPrompt::placeholder {
      color: #888;
    }

    button {
      color: #fff;
      border: none;
      margin-top: 10px;
      margin-right: 10px;
      cursor: pointer;
      padding: 10px 20px;
      border-radius: 15px;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #333;
    }

    h1,
    h4 {
      margin-bottom: 20px;
    }

    .spacer {
      padding: 0px 0px;
      flex-grow: 1;
    }

    [title] {
      cursor: help;
    }

    #title {
      text-align: center;
    }

    .background-image-wrapper {
      position: fixed;
      bottom: 0;
      right: 0;
      z-index: -1;
      pointer-events: auto;
    }

    .background-image {
      width: 200px;
      /* Adjust as needed */
      height: auto;
      opacity: 0.5;
      /* Optional: Adjust opacity */
      transition: opacity 0.3s;
    }

    .transparent-element,
    .transparent-element * {
      pointer-events: none;
    }

    #toggleDescription {
      background: #33333344;
      color: #fff;
      border: none;
      padding: 10px 20px;
      border-radius: 15px;
      cursor: pointer;
      transition: background-color 0.3s;
      margin-bottom: 10px;
    }

    #toggleDescription:hover {
      background-color: #333;
    }

    #description {
      background: #33333344;
      padding: 10px 20px;
      border-radius: 15px;
      color: #fff;
    }

    #scrollToTop {
      bottom: 20px;
      right: 50%;
      background: #33333344;
      color: #fff;
      border: none;
      padding: 10px 20px;
      border-radius: 15px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    #scrollToTop:hover {
      background-color: #333;
    }

    .trait-input {
      display: flex;
      align-items: center;
      margin-top: 20px;
    }

    .trait-input input {
      flex-grow: 1;
      margin-right: 10px;
    }

    .trait-input button {
      background: #33333344;
      color: #fff;
      border: none;
      padding: 5px 10px;
      border-radius: 15px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .trait-input button:hover {
      background-color: #333;
    }

    .delete-trait {
      background: #33000044;
      color: #fff;
      border: none;
      padding: 2px 10px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      margin-left: 10px;
    }

    .delete-trait:hover {
      background-color: #300;
    }

    .trait {
      display: flex;
      flex-direction: column;
      margin-bottom: 15px;
      width: 100%
    }

    .trait-header {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .trait-label {
      display: inline-block;
      width: 150px;
      max-width: 150px;
    }

    .trait-top-row {
      display: flex;
      align-items: center;
      width: 100%;
      flex-wrap: wrap;
    }

    .trait-slider {
      -webkit-appearance: none;
      appearance: none;
      flex-grow: 1;
      height: 10px;
      width: auto;
      max-width: 50%;
      offset: 0px 10px;
      padding: 0px;
      margin-top: 20px;
      outline: none;

    }

    .trait-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 25px;
      height: 25px;
      background: #8888;
      border-radius: 25px;
    }

    .trait-slider::-moz-range-thumb {
      border: 0;
      width: 25px;
      height: 25px;
      background: #8888;
      border-radius: 25px;
    }

    .delete-trait,
    .lock-trait,
    .lock-attribute {
      background: #33333344;
      color: #fff;
      border: none;
      padding: 2px 10px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      margin-left: 5px;
      font-size: 16px;
    }

    .delete-trait:hover,
    .lock-trait:hover,
    .lock-attribute:hover {
      background-color: #333;
    }

    .trait input[type="text"] {
      width: 100%;
      box-sizing: border-box;
    }

    .lock-trait,
    .lock-attribute {
      transition: background-color 0.3s ease;
    }

    .lock-trait.locked,
    .lock-attribute.locked {
      background-color: rgba(0, 100, 0, 0.5);
      /* Dark transparent green */
    }

    .prompt-box {
      border: 1px solid #33333344;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      background-color: #33333344;
    }

    .prompt-box h2 {
      margin-top: 0;
      color: #f0f0f0;
    }

    #step2Prompts {
      opacity: 0.5;
      pointer-events: none;
    }

    #step2Prompts.active {
      opacity: 1;
      pointer-events: auto;
    }

    #digestedTraits {
      width: calc(100% - 20px);
      height: 100px;
      margin-bottom: 10px;
      background-color: #2222;
      color: #fff;
      border: 1px solid #333;
      border-radius: 15px;
      padding: 10px;
      resize: vertical;
    }

    .trait-input {
      display: flex;
      margin-bottom: 10px;
    }

    .prompt-box.foldable {
      border: 1px solid rgba(204, 204, 204, 0.2);
      margin-bottom: 10px;
      background-color: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(5px);
    }

    .prompt-title {
      color: inherit;
      padding: 10px;
      margin: 0;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .prompt-content {
      display: none;
      padding: 10px;
    }

    .prompt-box.foldable.active .prompt-content {
      display: block;
    }

    .prompt-title::after {
      content: '‚ñº';
      float: right;
      transition: transform 0.3s ease;
    }

    .prompt-box.foldable.active .prompt-title::after {
      transform: rotate(180deg);
    }

    #copyNotification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(42, 42, 42, 0.9);
      color: #ffffff;
      padding: 15px 25px;
      border-radius: 8px;
      font-family: Arial, sans-serif;
      font-size: 18px;
      font-weight: bold;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
      z-index: 1000;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>

<body>
  <div id="copyNotification">Copied ‚úÖ</div>
  <h1 id="title">‚ú®Character Prompt Generator for Janitorai‚ú®</h1>
  <button id="toggleDescription">How does this work?</button>
  <div id="description" style="display: none;">
    <h4><u>Make any sort of role play bot you want in just a few minutes!</u></h4>
    <div style="margin-left: 20px">
      <p>1. Generate and modify the character traits below</p>
      <p>2. Fill in any details you want for your character in the short custom prompt box.</p>
      <p>3. Copy a prompt from the single or two step prompt area</p>
      <p>4. Go to an AI site and paste your prompt.</p>
      <p>5. If you're using the 2 step prompts, paste the result from the AI in step 1 in the box and then copy the step
        2 prompt. Next, go back to the AI in a new chat, and
        use the prompt to get the final character card.
      </p>
    </div>
    <h4><u>But where do I paste my prompts???</u></h4>
    <div style="margin-left: 20px">
      <p>I recommend using the Command R Plus model to generate any (nsfw)
        character
        card for free over at <a href="https://huggingface.co/chat"> Huggingchat</a></p>
      <p>JLLM works alright now too. You can try it with <a
          href="https://janitorai.com/characters/26902018-a3d7-4b05-bbf9-c08c00300ad2_character-chat-gpt-plus-your-versatile-ai">this
          ChatGPT character here</a>. With JLLM, hit the edit button on its reply to copy the unformatted text with
        markdown punctuation
        in tact.</p>
      <p>ChatGPT is good but the explicit prompts will trip moderation and eventually get you banned there!</p>
    </div>
  </div><br>
  </div><br><br>
  <div class="prompt-box foldable">
    <h4 class="prompt-title">Single Step Prompts</h4>
    <div class="prompt-content">
      <p>AI makes a character card right now in one step with this prompt</p>
      <button onclick="copyWithPrompt(prompt_template)">Copy With Prompt</button>
      <button onclick="copyWithPrompt(nsfw_prompt_template)">Copy With Explicit Prompt</button>
    </div>
  </div>

  <div class="prompt-box foldable">
    <h4 class="prompt-title">Two Step Prompts</h4>
    <div class="prompt-content">
      <p>For better results, use the step 1 prompt and paste the results here, and then get an improved character card
        from the step 2 prompt.</p>
      <button onclick="generateStep1Prompt()">Step 1 Prompt</button>
      <textarea id="digestedTraits" placeholder="Paste the results from Step 1 here"></textarea>
      <div id="step2Prompts">
        <button onclick="copyWithStep2Prompt(prompt_template)">Step 2 Prompt</button>
        <button onclick="copyWithStep2Prompt(nsfw_prompt_template)">Explicit Step 2 Prompt</button>
      </div>
    </div>
  </div>
  <div>
    <label>Short Prompt:</label>
    <textarea id="customPrompt"
      placeholder="Enter a short custom prompt to guide the AI character generation process, e.g. 'He's a billionaire CEO' (optional)"></textarea>
  </div>
  <button onclick="generateAll()">Reroll Traits</button>
  <button onclick="copyAll()">Copy Traits</button>
  <button onclick="resetTraits()">Reset Traits</button><br><br>
  <div id="attributes"></div>
  <div id="traits"></div>
  <div class="trait-input">
    <input type="text" id="newTraitInput" placeholder="Add new trait">
    <button onclick="addNewTrait()">+</button>
  </div>
  <div class="background-image-wrapper">
    <img src="image.webp" alt="Background Image" class="background-image">
  </div>
  <button id="scrollToTop">Top</button><br><br>
  <footer
    style="background-color: #1113; padding: 0px 0; text-align: center; bottom: 0; width: 100%; border-radius: 15px">
    <p style="margin: 0;">
      If you find this tool helpful, consider
      <a href="https://buymeacoffee.com/trainraider" target="_blank">
        buying me a coffee ‚òï
      </a>
    </p>
  </footer>
  <script>

    const ATTRIBUTES_INFO = {
      'Gender': ['Man', 'Woman'],
      'Age': Array.from({ length: 18 }, (_, i) => i + 18),
      'Era': ['Medieval', 'Modern', 'Futuristic'],
      'World Type': ['Realistic', 'Fantasy'],
      'Race': ['Human', 'Elf', 'Goblin', 'Orc'] // Only if fantasy
    };

    const DEFAULT_TRAITS = [
      'Narcissism', 'Machiavellianism', 'Sadism', 'Psychopathy',
      'Wealth', 'Societal status', 'Strength', 'Intelligence', 'Wisdom',
      'Physical attractiveness', 'Horniness'
    ];

    const PERSONALITY_TRAITS = [
      "Adventurous", "Ambitious", "Analytical", "Arrogant", "Assertive", "Bigotted", "Brave",
      "Careless", "Captivating", "Cautious", "Charismatic", "Cheerful", "Compassionate", "Competent", "Confident",
      "Conservative", "Creative", "Cynical", "Decisive", "Determined", "Diligent", "Dramatic",
      "Dishonest", "Disorganized", "Eccentric", "Empathetic", "Enthusiastic", "Extroverted", "Flirtatious", "Focused",
      "Forgiving", "Generous", "Greedy", "Honest", "Humble", "Idealistic", "Imaginative", "Impulsive",
      "Independent", "Intelligent", "Introverted", "Intuitive", "Irresponsible", "Jealous", "Lazy", "Lecherous", "Liberal",
      "Logical", "Loyal", "Lustful", "Manipulative", "Melancholic", "Meticulous", "Modest", "Naive",
      "Narcissistic", "Neurotic", "Observant", "Optimistic", "Passionate", "Patient", "Perfectionist",
      "Persistent", "Persuasive", "Pessimistic", "Philosophical", "Pragmatic", "Procrastinates", "Prideful", "Rational", "Rebellious",
      "Reckless", "Reserved", "Resourceful", "Romantic", "Sarcastic", "Scholarly", "Self-absorbed", "Selfish",
      "Sensitive", "Sensual", "Skeptical", "Slutty", "Socially awkward", "Stoic", "Stubborn",
      "Suspicious", "Sympathetic", "Tactful", "Temperamental", "Tenacious", "Thoughtful", "Timid",
      "Tolerant", "Treacherous", "Trustworthy", "Uncompromising", "Unpredictable", "Vengeful",
      "Visionary", "Witty", "Wrathful"
    ];

    // Utility functions
    function getStrengthModifier(value, trait) {
      const levels = [
        { threshold: 0, modifier: "no {{trait}} at all" },
        { threshold: 10, modifier: "practically nonexistent {{trait}}" },
        { threshold: 20, modifier: "almost no {{trait}}" },
        { threshold: 25, modifier: "very low {{trait}}" },
        { threshold: 35, modifier: "considerably below average {{trait}}" },
        { threshold: 40, modifier: "less than average {{trait}}" },
        { threshold: 45, modifier: "average {{trait}}" },
        { threshold: 50, modifier: "moderate {{trait}}" },
        { threshold: 60, modifier: "above average {{trait}}" },
        { threshold: 70, modifier: "substantial {{trait}}" },
        { threshold: 80, modifier: "remarkable {{trait}}" },
        { threshold: 87, modifier: "extraordinary {{trait}}" },
        { threshold: 94, modifier: "unparalleled {{trait}}" }
      ];
      value = Number(value);

      // Handle numbers outside the 0-100 range
      if (value < 0) return `Less than no ${trait.toLowerCase()}, quite the opposite in fact`;
      if (value > 100) return `transcendental, superhuman ${trait.toLowerCase()}`;

      for (let i = levels.length - 1; i >= 0; i--) {
        if (value >= levels[i].threshold) {
          let modifier = levels[i].modifier;
          return modifier.includes("{{trait}}") ? modifier.replace("{{trait}}", trait.toLowerCase()) : `${modifier} ${trait.toLowerCase()}`;
        }
      }
      return `unknown amount of ${trait}`;
    }
    
    class Attribute {
      constructor(name, options) {
        this.name = name;
        this.options = options;
        this.value = this.generateRandomValue();
        this.element = null;
        this.locked = false;
      }

      generateRandomValue() {
        if (Array.isArray(this.options)) {
          return this.options[Math.floor(Math.random() * this.options.length)];
        } else {
          return Math.floor(Math.random() * (this.options[1] - this.options[0] + 1)) + this.options[0];
        }
      }

      generateElement() {
        const div = document.createElement('div');
        div.className = 'attribute';
        div.innerHTML = `
      <button class="lock-attribute" onclick="toggleAttributeLock('${this.name}')">${this.locked ? 'üîí' : 'üîì'}</button>
      ${this.name}: <br><br><input type="text" value="${this.value}">
    `;
        this.element = div;

        // Add event listener to the input
        const input = div.querySelector('input');
        input.addEventListener('input', (e) => {
          if (!this.locked) {
            this.value = e.target.value;
          }
        });

        return div;
      }

      toggleLock() {
        this.locked = !this.locked;
        if (this.element) {
          const lockButton = this.element.querySelector('.lock-attribute');
          const input = this.element.querySelector('input');
          lockButton.textContent = this.locked ? 'üîí' : 'üîì';
          lockButton.classList.toggle('locked', this.locked);
          input.disabled = this.locked;
        }
      }

      updateValue(newValue) {
        if (!this.locked) {
          this.value = newValue;
          if (this.element) {
            const input = this.element.querySelector('input');
            input.value = newValue;
          }
        }
      }
    }

    function setupAttributeListeners() {
      const attributesElement = document.getElementById('attributes');
      const attributeInputs = attributesElement.querySelectorAll('input');

      attributeInputs.forEach(input => {
        const attributeName = input.closest('.attribute').textContent.split(':')[0].trim();
        const attribute = attributeContainer.attributes[attributeName];

        input.addEventListener('input', (e) => {
          if (!attribute.locked) {
            attribute.value = e.target.value;
          }
        });
      });
    }

    class AttributeContainer {
      constructor() {
        this.attributes = {};
      }

      addAttribute(name, options) {
        this.attributes[name] = new Attribute(name, options);
      }

      generateElements(parentElement) {
        parentElement.innerHTML = '';
        for (const attribute of Object.values(this.attributes)) {
          parentElement.appendChild(attribute.generateElement());
        }
      }

      generateRandomValues() {
        for (const attribute of Object.values(this.attributes)) {
          if (!attribute.locked) {
            attribute.updateValue(attribute.generateRandomValue());
          }
        }
      }
    }

    class Trait {
      constructor(name) {
        this.name = name;
        this.value = Math.floor(Math.random() * 101);
        this.element = null;
        this.locked = false;
      }

      generateElement() {
        const div = document.createElement('div');
        div.className = 'trait';
        div.innerHTML = `
                <div class="trait-top-row">
                    <button class="lock-trait" onclick="toggleLock('${this.name}')">${this.locked ? 'üîí' : 'üîì'}</button>
                    <button class="delete-trait" onclick="deleteTrait('${this.name}')">‚ùå</button>
                    <span class="trait-label">${this.name}:</span>
                    <input type="range" class="trait-slider" min="0" max="100" value="${this.value}">
                </div>
                <input type="text" class="trait-input" placeholder="${this.getStrengthModifier()}">
            `;
        this.element = div;

        const slider = div.querySelector('.trait-slider');
        const input = div.querySelector('.trait-input');

        slider.addEventListener('input', () => {
          this.updateValue(slider.value);
          input.placeholder = this.getStrengthModifier();
          if (!input.value) {
            input.value = '';
          }
        });

        return div;
      }

      updateValue(newValue) {
        if (!this.locked) {
          this.value = newValue;
          if (this.element) {
            const slider = this.element.querySelector('.trait-slider');
            const input = this.element.querySelector('.trait-input');
            slider.value = newValue;
            input.placeholder = this.getStrengthModifier();
            if (!input.value) {
              input.value = '';
            }
          }
        }
      }

      toggleLock() {
        this.locked = !this.locked;
        if (this.element) {
          const lockButton = this.element.querySelector('.lock-trait');
          const slider = this.element.querySelector('.trait-slider');
          const input = this.element.querySelector('.trait-input');
          lockButton.textContent = this.locked ? 'üîí' : 'üîì';
          lockButton.classList.toggle('locked', this.locked);
          slider.disabled = this.locked;
          input.disabled = this.locked;
        }
      }

      getStrengthModifier() {
        const levels = [
          { threshold: 0, modifier: "no {{trait}} at all" },
          { threshold: 10, modifier: "practically nonexistent {{trait}}" },
          { threshold: 20, modifier: "almost no {{trait}}" },
          { threshold: 25, modifier: "very low {{trait}}" },
          { threshold: 35, modifier: "considerably below average {{trait}}" },
          { threshold: 40, modifier: "less than average {{trait}}" },
          { threshold: 45, modifier: "average {{trait}}" },
          { threshold: 50, modifier: "moderate {{trait}}" },
          { threshold: 60, modifier: "above average {{trait}}" },
          { threshold: 70, modifier: "substantial {{trait}}" },
          { threshold: 80, modifier: "remarkable {{trait}}" },
          { threshold: 87, modifier: "extraordinary {{trait}}" },
          { threshold: 94, modifier: "unparalleled {{trait}}" }
        ];

        for (let i = levels.length - 1; i >= 0; i--) {
          if (this.value >= levels[i].threshold) {
            return levels[i].modifier.replace("{{trait}}", this.name.toLowerCase());
          }
        }
        return "invalid {{trait}}".replace("{{trait}}", this.name.toLowerCase());
      }
    }

    class TraitContainer {
      constructor() {
        this.traits = {};
      }

      addTrait(name) {
        this.traits[name] = new Trait(name);
      }

      generateElements(parentElement) {
        parentElement.innerHTML = '';
        for (const trait of Object.values(this.traits)) {
          parentElement.appendChild(trait.generateElement());
        }
      }

      generateRandomValues() {
        for (const trait of Object.values(this.traits)) {
          if (!trait.locked) {
            const randomValue = Math.floor(Math.random() * 101);
            trait.updateValue(randomValue);
          }
        }
      }
    }

    function toggleLock(traitName) {
      const trait = traitContainer.traits[traitName];
      if (trait) {
        trait.toggleLock();
      }
    }

    document.addEventListener('DOMContentLoaded', (event) => {
      const toggleButton = document.getElementById('toggleDescription');
      const description = document.getElementById('description');

      toggleButton.addEventListener('click', () => {
        if (description.style.display === 'none') {
          description.style.display = 'block';
          toggleButton.textContent = 'Hide';
        } else {
          description.style.display = 'none';
          toggleButton.textContent = 'How does this work?';
        }
      });

      const scrollToTopButton = document.getElementById('scrollToTop');

      scrollToTopButton.addEventListener('click', () => {
        window.scrollTo({ top: 0 });
      });

      const backgroundImageWrapper = document.querySelector('.background-image-wrapper');
      const backgroundImage = document.querySelector('.background-image');

      function checkHover(event) {
        const rect = backgroundImageWrapper.getBoundingClientRect();
        let clientX, clientY;

        if (event.type.includes('touch')) {
          clientX = event.touches[0].clientX;
          clientY = event.touches[0].clientY;
        } else {
          clientX = event.clientX;
          clientY = event.clientY;
        }

        const isHovering = (
          clientX >= rect.left &&
          clientX <= rect.right &&
          clientY >= rect.top &&
          clientY <= rect.bottom
        );

        if (isHovering) {
          backgroundImage.src = 'image2.webp';
        } else {
          backgroundImage.src = 'image.webp';
        }
      }

      document.addEventListener('mousemove', checkHover);
      document.addEventListener('touchmove', checkHover);
      document.addEventListener('touchstart', checkHover); // for initial touch
    });

    const traitContainer = new TraitContainer();

    DEFAULT_TRAITS.forEach(traitName => traitContainer.addTrait(traitName));

    function initializeTraits() {
      DEFAULT_TRAITS.forEach(traitName => traitContainer.addTrait(traitName));
      const traitsElement = document.getElementById('traits');
      traitContainer.generateElements(traitsElement);
    }

    function rerollTraits() {
      for (const trait of Object.values(traitContainer.traits)) {
        if (!trait.locked) {
          const newValue = Math.floor(Math.random() * 101);
          trait.updateValue(newValue);
          if (trait.element) {
            const slider = trait.element.querySelector('.trait-slider');
            const input = trait.element.querySelector('.trait-input');
            slider.value = newValue;
            input.placeholder = trait.getStrengthModifier();
          }
        }
      }
    }

    function rerollAttributes() {
      for (const attribute of Object.values(attributeContainer.attributes)) {
        if (!attribute.locked) {
          const newValue = attribute.generateRandomValue();
          attribute.updateValue(newValue);
          if (attribute.element) {
            const input = attribute.element.querySelector('input');
            input.value = newValue;
          }
        }
      }

      // Special case for race if World Type is not fantasy
      const worldTypeAttribute = attributeContainer.attributes['World Type'];
      const raceAttribute = attributeContainer.attributes['Race'];
      if (worldTypeAttribute && raceAttribute) {
        if (worldTypeAttribute.value !== 'Fantasy' && !raceAttribute.locked) {
          raceAttribute.updateValue('Human');
        }
      }
    }

    function resetTraits() {
      traitContainer.traits = {};
      DEFAULT_TRAITS.forEach(traitName => traitContainer.addTrait(traitName));
      generateTraits();
    }

    function addNewTrait() {
      const newTraitInput = document.getElementById('newTraitInput');
      const newTraitName = newTraitInput.value.trim();
      if (newTraitName && !traitContainer.traits[newTraitName]) {
        const randomValue = Math.floor(Math.random() * 101);
        traitContainer.addTrait(newTraitName, randomValue);
        const traitsElement = document.getElementById('traits');
        traitsElement.appendChild(traitContainer.traits[newTraitName].generateElement());
        newTraitInput.value = '';
      }
    }

    function deleteTrait(traitName) {
      delete traitContainer.traits[traitName];
      const traitsElement = document.getElementById('traits');
      traitContainer.generateElements(traitsElement);
    }


    // Initialize the attribute container
    const attributeContainer = new AttributeContainer();

    // Populate the attribute container
    Object.entries(ATTRIBUTES_INFO).forEach(([key, options]) => {
      attributeContainer.addAttribute(key, options);
    });

    function generateAll() {
      rerollAttributes();
      rerollTraits();
    }

    function generateAttributes() {
      const attributesElement = document.getElementById('attributes');
      attributeContainer.generateElements(attributesElement);

      // Special case for race if World Type is not fantasy
      const worldTypeAttribute = attributeContainer.attributes['World Type'];
      const raceAttribute = attributeContainer.attributes['Race'];
      if (worldTypeAttribute && raceAttribute) {
        if (worldTypeAttribute.value !== 'Fantasy') {
          raceAttribute.updateValue('Human');
        }
      }
    }

    function toggleAttributeLock(attributeName) {
      const attribute = attributeContainer.attributes[attributeName];
      if (attribute) {
        attribute.toggleLock();
      }
    }

    function generateTraits() {
      const traitsElement = document.getElementById('traits');
      traitsElement.innerHTML = '';
      for (const [name, trait] of Object.entries(traitContainer.traits)) {
        if (!trait.locked) {
          trait.value = Math.floor(Math.random() * 101);
        }
        traitsElement.appendChild(trait.generateElement());
      }
    }

    function generateStep1Prompt() {
      let allText = generateTraitAttributeText();
      const customPromptText = document.getElementById('customPrompt').value.trim();

      const step1Prompt = `Based on the following information about a character:
        ${allText}
        ${customPromptText}

        And considering this list of personality traits: ${PERSONALITY_TRAITS.join(', ')}
        Please list the personality traits from the provided list that most apply to this character based on the information given. Your list should only be space separated. You can also use traits that weren't listed in your list. Put your answer in a code block.`;

      copyToClipboard(step1Prompt);
    }

    function copyWithStep2Prompt(promptTemplate) {
      const digestedTraits = document.getElementById('digestedTraits').value.trim();
      if (!digestedTraits) {
        return;
      }

      // Generate text for attributes
      let attributesText = generateAttributeText() + 'Personality:\n';
      let allText = attributesText + digestedTraits;

      const customPromptText = document.getElementById('customPrompt').value.trim();
      const finalText = promptTemplate
        .replace('{{traits}}', allText)
        .replace('{{custom_prompt}}', customPromptText);

      copyToClipboard(finalText);
    }

    document.getElementById('digestedTraits').addEventListener('input', function () {
      const step2Prompts = document.getElementById('step2Prompts');
      if (this.value.trim()) {
        step2Prompts.classList.add('active');
      } else {
        step2Prompts.classList.remove('active');
      }
    });

    function generateAttributeText() {
      let attributesText = '';
      for (const attribute of Object.values(attributeContainer.attributes)) {
        attributesText += `${attribute.name}: ${attribute.value}\n`;
      }
      // Remove any leading/trailing whitespace and ensure no empty lines
      attributesText = attributesText.trim().replace(/^\s+/gm, '');
      // Add a single newline at the end
      return attributesText + '\n';
    }

    // Helper function to generate trait/attribute text
    function generateTraitAttributeText() {
      let allText = '';

      // Generate text for attributes
      allText += generateAttributeText();

      // Generate text for traits
      document.querySelectorAll('.trait').forEach(traitElement => {
        let traitName = traitElement.querySelector('.trait-label').textContent.replace(':', '').trim();
        let sliderValue = traitElement.querySelector('.trait-slider').value;
        let textInputValue = traitElement.querySelector('.trait-input').value;

        if (textInputValue) {
          allText += `${traitName}: ${textInputValue}\n`;
        } else {
          let strengthModifier = getStrengthModifier(Number(sliderValue), traitName);
          allText += `${strengthModifier}\n`;
        }
      });

      return allText;
    }

    function showCopyNotification() {
      const notification = document.getElementById('copyNotification');
      notification.style.opacity = '1';
      notification.style.visibility = 'visible';
      setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.visibility = 'hidden';
      }, 1000);
    }

    function copyToClipboard(text) {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
      showCopyNotification();
    }
    function copyAll() {
      let allText = generateTraitAttributeText();
      copyToClipboard(allText);
    }

    function copyWithPrompt(prompt) {
      let allText = generateTraitAttributeText();
      const customPromptText = document.getElementById('customPrompt').value.trim();
      const finalText = prompt
        .replace('{{traits}}', allText)
        .replace('{{custom_prompt}}', customPromptText);

      copyToClipboard(finalText);
    }


    function setupNewTraitInput() {
      const newTraitInput = document.getElementById('newTraitInput');
      const addButton = document.querySelector('.trait-input button');

      newTraitInput.addEventListener('keypress', function (event) {
        if (event.key === 'Enter') {
          event.preventDefault(); // Prevent form submission if it's in a form
          addNewTrait();
        }
      });

      // Keep the existing click event for the button
      addButton.onclick = addNewTrait;
    }
    
    document.addEventListener('DOMContentLoaded', () => {
      const foldableBoxes = document.querySelectorAll('.prompt-box.foldable');

      foldableBoxes.forEach(box => {
        const title = box.querySelector('.prompt-title');
        title.addEventListener('click', () => {
          box.classList.toggle('active');
        });
      });

      setupNewTraitInput();
      initializeTraits();
      generateAll();
      generateAttributes();
      setupAttributeListeners();
    });